#!/usr/bin/env python
"""
Provides fuzzer leaf nodes in support of the process of acquiring an exploit for the vulnerability
"""
#  Copyright (c) 2023 Carnegie Mellon University and Contributors.
#  - see Contributors.md for a full list of Contributors
#  - see ContributionInstructions.md for information on how you can Contribute to this project
#  Vultron Multiparty Coordinated Vulnerability Disclosure Protocol Prototype is
#  licensed under a MIT (SEI)-style license, please see LICENSE.md distributed
#  with this Software or contact permission@sei.cmu.edu for full terms.
#  Created, in part, with funding and support from the United States Government
#  (see Acknowledgments file). This program may include and/or can make use of
#  certain third party source code, object code, documentation and other files
#  (“Third Party Software”). See LICENSE.md for more details.
#  Carnegie Mellon®, CERT® and CERT Coordination Center® are registered in the
#  U.S. Patent and Trademark Office by Carnegie Mellon University
from vultron.bt.base.factory import fuzzer
from vultron.bt.base.fuzzer import (
    AlmostAlwaysFail,
    AlmostAlwaysSucceed,
    AlwaysSucceed,
    OftenFail,
    OftenSucceed,
    RarelySucceed,
    UsuallyFail,
)


# check a database of exploits or threat intelligence feeds or ask a human
HaveExploit = fuzzer(
    UsuallyFail,
    "HaveExploit",
    """This condition is used to check if the organization already has an exploit for the vulnerability. In a real
    implementation, this could be a simple check to see if the organization already has an exploit for the
    vulnerability. For example, by checking a database of exploits or by checking threat intelligence feeds. In our
    stub implementation, this condition fails in 3 out of 4 attempts so that we can exercise the rest of the workflow.
    """,
)


# check against the result of an exploit acquisition priority evaluation or ask a human
ExploitDeferred = fuzzer(
    OftenSucceed,
    "ExploitDeferred",
    """This condition is used to check if the organization has decided to defer the acquisition of an exploit. This
    could be because the organization has decided to focus on other vulnerabilities or because the organization has
    decided to wait for a public exploit. In a real implementation, this could be a simple check against the result
    of an exploit acquisition priroity evaluation. In our stub implementation, this condition succeeds in 7 out of 10
    attempts.
    """,
)


# check process metadata or ask a human
ExploitPrioritySet = fuzzer(
    AlmostAlwaysSucceed,
    "ExploitPrioritySet",
    """This condition checks to see if the organization has decided on a priority for acquiring an exploit.
    In a real implementation, this could be a simple process metadata check.
    In our stub implementation, this condition succeeds in 9 out of 10 attempts.
    """,
)


# ask a human
EvaluateExploitPriority = fuzzer(
    AlwaysSucceed,
    "EvaluateExploitPriority",
    """This node represents the process of evaluating the priority of acquiring an exploit. In a real implementation,
    this would probably be a human decision based on a variety of factors. Or it might be automated if the
    organization has a clear data-driven process for evaluating exploit acquisition priority. In our stub
    implementation, this node always succeeds.
    """,
)


# check against the result of an exploit acquisition priority evaluation or ask a human
ExploitDesired = fuzzer(
    OftenFail,
    "ExploitDesired",
    """This condition represents the organization's decision to acquire an exploit, based on the priority evaluation. In
    a real implementation, this could be a simple check against the result of an exploit acquisition priority
    evaluation. In our stub implementation, this condition fails in 7 out of 10 attempts.
    """,
)


# search for an exploit in a database of exploits or threat intelligence feeds or ask a human
FindExploit = fuzzer(
    AlmostAlwaysFail,
    "FindExploit",
    """This node represents the process of finding an exploit for the vulnerability outside of the organization. In a
    real implementation, this might be automated as a search for an exploit in a database of exploits or a search for
    an exploit in threat intelligence feeds. Alternatively, this might be a prompt for a human to go search for an
    exploit. In our stub implementation, this node fails in 9 out of 10 attempts, reflecting the assumption that
    exploits are usually not readily available, while still succeeding often enough to exercise the rest of the
    workflow.
    """,
)


# ask a human
DevelopExploit = fuzzer(
    OftenSucceed,
    "DevelopExploit",
    """This node represents the process of developing an exploit for the vulnerability. In a real implementation,
    this would probably be a prompt for a human to develop an exploit. In our stub implementation, this node succeeds
    in 7 out of 10 attempts, allowing us to exercise the rest of the workflow.
    """,
)


# ask a human
PurchaseExploit = fuzzer(
    RarelySucceed,
    "PurchaseExploit",
    """This node represents the process of purchasing an exploit for the vulnerability. In a real implementation,
    this would probably be a prompt for a human to pursue purchasing an exploit. In our stub implementation,
    this node succeeds in 1 out of 10 attempts, allowing us to exercise the rest of the workflow.
    """,
)
