# Implementation Notes

Longer-term notes can be found in `/notes/*.md`. This file is ephemeral
and will be reset periodically, so it's meant to capture more immediate
insights, issues, and learnings during the implementation process.

Add new items below this line

---

## Outbox Delivery Gap

`vultron/api/v2/data/actor_io.py` has a placeholder that appends strings to an
outbox list but does not write to any recipient actor's inbox. No delivery
mechanism exists. This means outbox-based activities (e.g., CreateCase
activity generated by `create_case` handler) are never actually received by
other actors. This is acceptable for the prototype demos (which sequence
activities manually) but must be resolved before the `CaseActor` broadcast
model (Priority 200) can work correctly.

## CM-03-006 Rename Risk

`VulnerabilityCase.case_status` (list field with singular name) is referenced
throughout `handlers.py` (~20 call sites), `behaviors/`, and many tests.
The rename to `case_statuses` is a correctness improvement per the spec but
carries significant breakage risk. Run `grep -rn "\.case_status" vultron/ test/`
before starting to quantify scope. Consider doing `case_statuses` and
`participant_statuses` renames in the same PR to keep the diff localized.

## DEMO-4 Isolation Complexity

When running multiple demos in sequence (via the `all` sub-command), each demo
must leave the DataLayer in a clean state. The current demo scripts were each
designed to run against a clean slate. Key risks:

- Demos that create actors with fixed IDs (e.g., `vendor`, `finder`) will
  conflict on second run unless teardown deletes those actors.
- The `manage_case_demo` and `manage_embargo_demo` share similar object types;
  ensure teardown is comprehensive.
- Teardown should use the DataLayer directly (not via HTTP inbox) to guarantee
  cleanup even when the demo fails mid-way.

Consider designing a demo context manager that can be used as a `with` block
around each demo. The `__enter__` method can set up tracking to record the IDs of 
all created DataLayer entries, and the `__exit__` method can iterate those IDs and delete 
them from the DataLayer to ensure a clean slate for the next demo. 
This would also help ensure that teardown runs even if the demo encounters an 
error, as the `__exit__` method of a context manager is guaranteed to execute 
regardless of exceptions.

More generally: given the choice between implementing identical 
try/except/finally clean up logic when it will be repeated across multiple 
locations, versus implementing a reusable context manager that abstracts 
that logic, the context manager is likely the better choice for 
maintainability and reducing code duplication.

## DEMO-4 Docker Interaction Mode

The unified demo container should be interactive by default (`docker compose
run demo` or `docker compose up demo` with TTY). The `DEMO` env var override
(`DEMO=receive-report docker compose up demo`) is the non-interactive path for
CI or scripted runs. Verify that click's interactive prompts degrade gracefully
when stdin is not a TTY (use `click.echo` + non-interactive fallback if needed).

Also ensure that the startup process (presumably in `docker-compose.yml`?) demo 
container has appropriate dependency on the `api-dev` container so that 
running the demo container will also trigger the API container to start if 
it's not already running, and that the demo container waits for the API to 
be available before starting the demo script. This will help ensure a 
smoother  experience for users who may not have the API container already running.
We want this to be as turnkey as possible, so minimizing manual steps for demo
users is a key goal.

## DEMO-4.4 Isolation Implementation (2026-02-26)

Added `demo_environment(client)` context manager to `vultron/demo/utils.py`.
It calls `setup_clean_environment()` on entry and `reset_datalayer(init=False)` +
`clear_all_actor_ios()` in a `finally` block on exit. All 12 demo scripts updated
to use `with demo_environment(client) as (finder, vendor, coordinator):` in their
`main()` loops, replacing the bare `setup_clean_environment()` call. This satisfies
DC-03-001 (teardown runs even on exception) and DC-03-003 (each invocation manages
its own context).



The test suite is rather slow, largely because of the demo tests.
Consider either refactoring demo tests to be faster, more focused, less 
end-to-end, or moving them to a separate suite that can be deliberately chosen
when needed. Obviously segregating the tests doesn't help when running the full 
suite, so optimizing the tests themselves is likely necessary. This could be a
non-trivial task, so segmentation might be a good first step to allow for other
development to proceed without being bottlenecked by the test suite until 
the tests can be optimized.

## DEMO-4.3 Complete (2026-02-26)

All 12 `*_demo.py` scripts moved from `vultron/scripts/` to `vultron/demo/`.
Updated all test imports in `test/scripts/` (`from vultron.scripts import X_demo`
â†’ `from vultron.demo import X_demo`). Updated Dockerfile CMDs to use
`vultron.demo.X_demo`. 568 tests pass.

`vultron/demo/utils.py` created with all shared utilities extracted from
`initialize_case_demo.py`: `demo_step`, `demo_check`, `logfmt`, `postfmt`,
`BASE_URL`, `DataLayerClient`, `reset_datalayer`, `discover_actors`,
`init_actor_ios`, `post_to_inbox_and_wait`, `verify_object_stored`,
`get_offer_from_datalayer`, `log_case_state`, `setup_clean_environment`,
`check_server_availability`.

`initialize_case_demo.py` updated to import from `vultron.demo.utils`. All
other demo scripts continue to import via `initialize_case_demo` (DEMO-4.2
will update them to import directly from `vultron.demo.utils`).
568 tests pass.